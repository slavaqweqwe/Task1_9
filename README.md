Максимов Вячеслав 

3441102/00301


Task 1.9
Реализовать интерфейс для класса кодеров
Методы интерфейса:
std::vector<uint8_t> Encode(std::vector<uint8_t> const& data);
Реализовать 2 класса для кодирования один для кода хэмминга (7,4), второй на выбор
Входные и выходные данные представляются в виде битового потока т.е. один байт несет в себе 8 бит, при количестве бит не кратных байту последние биты заполняются 0. Кодировать необходимо именно биты!
В данном задании рассматривать uint8_t как набор из 8 битов, а не как число.



Результаты в тестах сравнивались с резульатами из маталаба, полученными скриптом снизу
У кода хэмминга в матлабе странная задача вхдных параметров( и выходных тоже) из за того что стандартная функция работает не по классике и всё переворачивает

%% Diff
a1=[1 0 0 0 0 0 0 0]
a2=[0 1 0 0 0 0 0 0]
a3=[1 1 0 0 0 0 0 0]
a4=[0 0 1 0 0 0 0 0]

diffEnc = comm.DifferentialEncoder;


data = [a1, a2, a3, a4]';
encData = diffEnc(data)
for j=0:length(data)/8-1
R1=0;
for i=0:7
R1=R1+encData(i+1+j*8)*2^i;
end
R1
end

%% Hamming
clear;
a(1,:)=[1 0 0 0 0 0 0 1];%129
a(2,:)=[1 1 1 1 1 1 1 1];%255
a(3,:)=[0 0 0 0 1 1 1 1];%240
a(4,:)=[0 0 0 0 0 0 0 0];%0


mat=[1 0 0 0 1 0 1; 0 1 0 0 1 1 1; 0 0 1 0 1 1 0; 0 0 0 1 0 1 1];
res=[];
for i=1:4
    res=[res mod(a(i,1:4)*mat,2)];
    res=[res mod(a(i,5:end)*mat,2)];
end
code=res;
num_simbols=size(a,1);
for j=0:fix(7*2*num_simbols/8)-1
R1=0;
for i=0:7
R1=R1+code(i+1+j*8)*2^i;
end
R1
end

if (length(code) - (fix(7*2*num_simbols/8)*8+1)>=0)
R1=0;
for i=0:length(code) - (fix(7*2*num_simbols/8)*8+1)
R1=R1+code(i+fix(7*2*num_simbols/8)*8+1)*2^i;
end
R1
end